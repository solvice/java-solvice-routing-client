/*
 * OnRoute API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.solvice.routing.api.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.solvice.routing.api.client.model.OrderDateWindows;
import io.solvice.routing.api.client.model.OrderWindows;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Order
 */

public class Order {

  @SerializedName("name")
  private String name = null;

  @SerializedName("location")
  private String location = null;
  /**
   * Activity type. When defining a PDP problem, be sure to have both a pickup and a delivery activity for the same ride. See ride.
   */
  @JsonAdapter(ActivityEnum.Adapter.class)
  public enum ActivityEnum {
    PICKUP("PICKUP"),
    DROPOFF("DROPOFF"),
    EXECUTE("EXECUTE"),
    BREAK("BREAK");

    private String value;

    ActivityEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ActivityEnum fromValue(String text) {
      for (ActivityEnum b : ActivityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ActivityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ActivityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ActivityEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ActivityEnum.fromValue(String.valueOf(value));
      }
    }
  }
  @SerializedName("activity")
  private ActivityEnum activity = ActivityEnum.PICKUP;

  @SerializedName("ride")
  private String ride = null;

  @SerializedName("priority")
  private Integer priority = null;

  @SerializedName("duration")
  private Integer duration = null;

  @SerializedName("demand")
  private Integer demand = null;

  @SerializedName("demand2")
  private Integer demand2 = null;

  @SerializedName("type")
  private List<String> type = null;

  @SerializedName("windows")
  private List<OrderWindows> windows = null;

  @SerializedName("durationSquash")
  private Integer durationSquash = null;

  @SerializedName("dateWindows")
  private List<OrderDateWindows> dateWindows = null;

  @SerializedName("allowedVehicles")
  private List<String> allowedVehicles = null;

  @SerializedName("disallowedVehicles")
  private List<String> disallowedVehicles = null;
  public Order name(String name) {
    this.name = name;
    return this;
  }

  

  /**
  * Unique name of an order
  * @return name
  **/
  @Schema(example = "order1", required = true, description = "Unique name of an order")
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public Order location(String location) {
    this.location = location;
    return this;
  }

  

  /**
  * Location of an order; should be in location list.
  * @return location
  **/
  @Schema(example = "Ghent, Belgium", required = true, description = "Location of an order; should be in location list.")
  public String getLocation() {
    return location;
  }
  public void setLocation(String location) {
    this.location = location;
  }
  public Order activity(ActivityEnum activity) {
    this.activity = activity;
    return this;
  }

  

  /**
  * Activity type. When defining a PDP problem, be sure to have both a pickup and a delivery activity for the same ride. See ride.
  * @return activity
  **/
  @Schema(description = "Activity type. When defining a PDP problem, be sure to have both a pickup and a delivery activity for the same ride. See ride.")
  public ActivityEnum getActivity() {
    return activity;
  }
  public void setActivity(ActivityEnum activity) {
    this.activity = activity;
  }
  public Order ride(String ride) {
    this.ride = ride;
    return this;
  }

  

  /**
  * Only applicable for PDP. Use the same ride string for a pickup and a delivery activity.
  * @return ride
  **/
  @Schema(description = "Only applicable for PDP. Use the same ride string for a pickup and a delivery activity.")
  public String getRide() {
    return ride;
  }
  public void setRide(String ride) {
    this.ride = ride;
  }
  public Order priority(Integer priority) {
    this.priority = priority;
    return this;
  }

  

  /**
  * Priority allows you to make certain visits a priority over others. In some cases you have more visits than you can serve, resulting in a few unserved. But if you want to make sure your high priority visits take precedence, use this parameter and set it to 100. 
  * minimum: 0
  * maximum: 1000
  * @return priority
  **/
  @Schema(example = "0", description = "Priority allows you to make certain visits a priority over others. In some cases you have more visits than you can serve, resulting in a few unserved. But if you want to make sure your high priority visits take precedence, use this parameter and set it to 100. ")
  public Integer getPriority() {
    return priority;
  }
  public void setPriority(Integer priority) {
    this.priority = priority;
  }
  public Order duration(Integer duration) {
    this.duration = duration;
    return this;
  }

  

  /**
  * Duration of the service in minutes
  * minimum: 0
  * maximum: 1439
  * @return duration
  **/
  @Schema(example = "25", description = "Duration of the service in minutes")
  public Integer getDuration() {
    return duration;
  }
  public void setDuration(Integer duration) {
    this.duration = duration;
  }
  public Order demand(Integer demand) {
    this.demand = demand;
    return this;
  }

  

  /**
  * Load in cargo for capacity type 1.
  * minimum: 0
  * @return demand
  **/
  @Schema(description = "Load in cargo for capacity type 1.")
  public Integer getDemand() {
    return demand;
  }
  public void setDemand(Integer demand) {
    this.demand = demand;
  }
  public Order demand2(Integer demand2) {
    this.demand2 = demand2;
    return this;
  }

  

  /**
  * Load in cargo for capacity type 2.
  * minimum: 0
  * @return demand2
  **/
  @Schema(description = "Load in cargo for capacity type 2.")
  public Integer getDemand2() {
    return demand2;
  }
  public void setDemand2(Integer demand2) {
    this.demand2 = demand2;
  }
  public Order type(List<String> type) {
    this.type = type;
    return this;
  }

  public Order addTypeItem(String typeItem) {
    if (this.type == null) {
      this.type = new ArrayList<String>();
    }
    this.type.add(typeItem);
    return this;
  }

  /**
  * Type restriction which can force some orders to be executed by Vehicles with the same type.
  * @return type
  **/
  @Schema(description = "Type restriction which can force some orders to be executed by Vehicles with the same type.")
  public List<String> getType() {
    return type;
  }
  public void setType(List<String> type) {
    this.type = type;
  }
  public Order windows(List<OrderWindows> windows) {
    this.windows = windows;
    return this;
  }

  public Order addWindowsItem(OrderWindows windowsItem) {
    if (this.windows == null) {
      this.windows = new ArrayList<OrderWindows>();
    }
    this.windows.add(windowsItem);
    return this;
  }

  /**
  * A time window consists of a starttime and an endtime. The order cannot be processed before the starttime and should start being processed before endtime. If the time window is hard, then it should always be fulfilled. E.g. a driver would prefer to drive 3 hours longer than not be on time wrt that time window for that order. So hard time window constraints are pretty extreme!
  * @return windows
  **/
  @Schema(description = "A time window consists of a starttime and an endtime. The order cannot be processed before the starttime and should start being processed before endtime. If the time window is hard, then it should always be fulfilled. E.g. a driver would prefer to drive 3 hours longer than not be on time wrt that time window for that order. So hard time window constraints are pretty extreme!")
  public List<OrderWindows> getWindows() {
    return windows;
  }
  public void setWindows(List<OrderWindows> windows) {
    this.windows = windows;
  }
  public Order durationSquash(Integer durationSquash) {
    this.durationSquash = durationSquash;
    return this;
  }

  

  /**
  * When multiple orders are on the same location, the service duration can be lower due to simultaneous handling. The duration will then be this value. is useful when you have many stops at the same location, which could be an apartment complex. Normally, each stop has a duration value of let&#x27;s say 10 minutes, which accounts for parking and finding the entrance. If you had 6 stops assigned to a driver at the same time, it doesn&#x27;t take an hour in total! Use this parameter to squash the durations of each subsequent delivery at the same address. If you set it to 1, it will squash it to 1 minute, so the total duration for the above 6 stops would be 15 minutes.
  * minimum: 0
  * @return durationSquash
  **/
  @Schema(example = "5", description = "When multiple orders are on the same location, the service duration can be lower due to simultaneous handling. The duration will then be this value. is useful when you have many stops at the same location, which could be an apartment complex. Normally, each stop has a duration value of let's say 10 minutes, which accounts for parking and finding the entrance. If you had 6 stops assigned to a driver at the same time, it doesn't take an hour in total! Use this parameter to squash the durations of each subsequent delivery at the same address. If you set it to 1, it will squash it to 1 minute, so the total duration for the above 6 stops would be 15 minutes.")
  public Integer getDurationSquash() {
    return durationSquash;
  }
  public void setDurationSquash(Integer durationSquash) {
    this.durationSquash = durationSquash;
  }
  public Order dateWindows(List<OrderDateWindows> dateWindows) {
    this.dateWindows = dateWindows;
    return this;
  }

  public Order addDateWindowsItem(OrderDateWindows dateWindowsItem) {
    if (this.dateWindows == null) {
      this.dateWindows = new ArrayList<OrderDateWindows>();
    }
    this.dateWindows.add(dateWindowsItem);
    return this;
  }

  /**
  * List of start/end date/time combinations.
  * @return dateWindows
  **/
  @Schema(description = "List of start/end date/time combinations.")
  public List<OrderDateWindows> getDateWindows() {
    return dateWindows;
  }
  public void setDateWindows(List<OrderDateWindows> dateWindows) {
    this.dateWindows = dateWindows;
  }
  public Order allowedVehicles(List<String> allowedVehicles) {
    this.allowedVehicles = allowedVehicles;
    return this;
  }

  public Order addAllowedVehiclesItem(String allowedVehiclesItem) {
    if (this.allowedVehicles == null) {
      this.allowedVehicles = new ArrayList<String>();
    }
    this.allowedVehicles.add(allowedVehiclesItem);
    return this;
  }

  /**
  * List of vehicle names that are allowed to be assigned to this order
  * @return allowedVehicles
  **/
  @Schema(description = "List of vehicle names that are allowed to be assigned to this order")
  public List<String> getAllowedVehicles() {
    return allowedVehicles;
  }
  public void setAllowedVehicles(List<String> allowedVehicles) {
    this.allowedVehicles = allowedVehicles;
  }
  public Order disallowedVehicles(List<String> disallowedVehicles) {
    this.disallowedVehicles = disallowedVehicles;
    return this;
  }

  public Order addDisallowedVehiclesItem(String disallowedVehiclesItem) {
    if (this.disallowedVehicles == null) {
      this.disallowedVehicles = new ArrayList<String>();
    }
    this.disallowedVehicles.add(disallowedVehiclesItem);
    return this;
  }

  /**
  * List of vehicle names that are not allowed to be assigned to this order
  * @return disallowedVehicles
  **/
  @Schema(description = "List of vehicle names that are not allowed to be assigned to this order")
  public List<String> getDisallowedVehicles() {
    return disallowedVehicles;
  }
  public void setDisallowedVehicles(List<String> disallowedVehicles) {
    this.disallowedVehicles = disallowedVehicles;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Order order = (Order) o;
    return Objects.equals(this.name, order.name) &&
        Objects.equals(this.location, order.location) &&
        Objects.equals(this.activity, order.activity) &&
        Objects.equals(this.ride, order.ride) &&
        Objects.equals(this.priority, order.priority) &&
        Objects.equals(this.duration, order.duration) &&
        Objects.equals(this.demand, order.demand) &&
        Objects.equals(this.demand2, order.demand2) &&
        Objects.equals(this.type, order.type) &&
        Objects.equals(this.windows, order.windows) &&
        Objects.equals(this.durationSquash, order.durationSquash) &&
        Objects.equals(this.dateWindows, order.dateWindows) &&
        Objects.equals(this.allowedVehicles, order.allowedVehicles) &&
        Objects.equals(this.disallowedVehicles, order.disallowedVehicles);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(name, location, activity, ride, priority, duration, demand, demand2, type, windows, durationSquash, dateWindows, allowedVehicles, disallowedVehicles);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Order {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    activity: ").append(toIndentedString(activity)).append("\n");
    sb.append("    ride: ").append(toIndentedString(ride)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    demand: ").append(toIndentedString(demand)).append("\n");
    sb.append("    demand2: ").append(toIndentedString(demand2)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    windows: ").append(toIndentedString(windows)).append("\n");
    sb.append("    durationSquash: ").append(toIndentedString(durationSquash)).append("\n");
    sb.append("    dateWindows: ").append(toIndentedString(dateWindows)).append("\n");
    sb.append("    allowedVehicles: ").append(toIndentedString(allowedVehicles)).append("\n");
    sb.append("    disallowedVehicles: ").append(toIndentedString(disallowedVehicles)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
